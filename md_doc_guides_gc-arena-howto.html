<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mruby: How to use `mrb_gc_arena_save()`/`mrb_gc_arena_restore()`/`mrb_gc_protect()`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="mruby_logo_red_icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mruby
   &#160;<span id="projectnumber">2.0.1</span>
   </div>
   <div id="projectbrief">mruby is the lightweight implementation of the Ruby language</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to use `mrb_gc_arena_save()`/`mrb_gc_arena_restore()`/`mrb_gc_protect()` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>This is an English translation of <a href="http://www.rubyist.net/~matz/20130731.html">Matz's blog post</a> written in Japanese.</em> <em>Some parts are updated to reflect recent changes.</em></p>
<p>When you are extending mruby using C language, you may encounter mysterious "arena overflow error" or memory leak or very slow execution speed. This is an error indicating overflow of "GC arena" implementing "conservative GC".</p>
<p>GC (garbage collector) must ensure that object is "alive", in other words, that it is referenced by somewhere from program. This can be determined by checking if the object can be directly or indirectly referenced by root. The local variables, global variables and constants etc are root.</p>
<p>If program execution is performed inside mruby VM, there is nothing to worry about because GC can access all roots owned by VM.</p>
<p>The problem arises when executing C functions. The object referenced by C variable is also "alive", but mruby GC cannot aware of this, so it might mistakenly recognize the objects referenced by only C variables as dead.</p>
<p>This can be a fatal bug if the GC tries to collect a live object.</p>
<p>In CRuby, we scan C stack area, and use C variable as root to check whether object is alive or not. Of course, because we are accessing C stack just as memory region, we never know it is an integer or a pointer. We workaround this by assuming that if it looks like a pointer, then assume it as a pointer. We call it "conservative".</p>
<p>By the way, CRuby's "conservative GC" has some problems.</p>
<p>The biggest problem is we have no way to access to the stack area in portable way. Therefore, we cannot use this method if we'd like to implement highly portable runtime, like mruby.</p>
<p>So we came up with an another plan to implement "conservative GC" in mruby.</p>
<p>Again, the problem is when an object which was created in C function, becomes no longer referenced in the Ruby world, and cannot be treated as garbage.</p>
<p>In mruby, we recognize all objects created in C function are alive. Then we have no problem such as confusing a live object as dead.</p>
<p>This means that because we cannot collect truly dead object, we may lose efficiency, but as a trade-off the GC itself is highly portable. We can say goodbye to the problem that GC deletes live objects due to optimization which sometimes occurs in CRuby.</p>
<p>According to this idea, we have a table, called "GC arena", which remembers objects created in C function.</p>
<p>The arena is stack structure, when C function execution is returned to mruby VM, all objects registered in the arena are popped.</p>
<p>This works very well, but can cause another problem: "arena overflow error" or memory leak.</p>
<p>As of this writing, mruby automatically extend arena to remember objects (See <code>MRB_GC_FIXED_ARENA</code> and <code>MRB_GC_ARENA_SIZE</code> in doc/guides/mrbconf.md).</p>
<p>If you create many objects in C functions, memory usage will increase, since GC never kick in. This memory usage may look like memory leak, but will also make execution slower as more memory will need to be allocated.</p>
<p>With the build time configuration, you can limit the maximum size of arena (e.g., 100). Then if you create many objects, arena overflows, thus you will get an "arena overflow error".</p>
<p>To workaround these problems, we have <code>mrb_gc_arena_save()</code> and <code>mrb_gc_arena_restore()</code> functions.</p>
<p><code>int mrb_gc_arena_save(mrb)</code> returns the current position of the stack top of GC arena, and <code>void mrb_gc_arena_restore(mrb, idx)</code> sets the stack top position to back to given <code>idx</code>.</p>
<p>We can use them like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> arena_idx = mrb_gc_arena_save(mrb);</div><div class="line"></div><div class="line"><span class="comment">// ...create objects...</span></div><div class="line">mrb_gc_arena_restore(mrb, arena_idx);</div></div><!-- fragment --><p>In mruby, C function calls are surrounded by this save/restore, but we can further optimize memory usage by surrounding save/restore, and can avoid creating arena overflow bugs.</p>
<p>Let's take a real example. Here is the source code of <code>Array::inspect</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="structmrb__value.html">mrb_value</a></div><div class="line">inspect_ary(<a class="code" href="structmrb__state.html">mrb_state</a> *mrb, <a class="code" href="structmrb__value.html">mrb_value</a> ary, <a class="code" href="structmrb__value.html">mrb_value</a> list)</div><div class="line">{</div><div class="line">  mrb_int i;</div><div class="line">  <a class="code" href="structmrb__value.html">mrb_value</a> s, arystr;</div><div class="line">  <span class="keywordtype">char</span> head[] = { <span class="charliteral">&#39;[&#39;</span> };</div><div class="line">  <span class="keywordtype">char</span> sep[] = { <span class="charliteral">&#39;,&#39;</span>, <span class="charliteral">&#39; &#39;</span> };</div><div class="line">  <span class="keywordtype">char</span> tail[] = { <span class="charliteral">&#39;]&#39;</span> };</div><div class="line"></div><div class="line">  <span class="comment">/* check recursive */</span></div><div class="line">  <span class="keywordflow">for</span>(i=0; i&lt;RARRAY_LEN(list); i++) {</div><div class="line">    <span class="keywordflow">if</span> (mrb_obj_equal(mrb, ary, RARRAY_PTR(list)[i])) {</div><div class="line">      <span class="keywordflow">return</span> mrb_str_new(mrb, <span class="stringliteral">&quot;[...]&quot;</span>, 5);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  mrb_ary_push(mrb, list, ary);</div><div class="line"></div><div class="line">  arystr = mrb_str_new_capa(mrb, 64);</div><div class="line">  mrb_str_cat(mrb, arystr, head, <span class="keyword">sizeof</span>(head));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(i=0; i&lt;RARRAY_LEN(ary); i++) {</div><div class="line">    <span class="keywordtype">int</span> ai = mrb_gc_arena_save(mrb);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (i &gt; 0) {</div><div class="line">      mrb_str_cat(mrb, arystr, sep, <span class="keyword">sizeof</span>(sep));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (mrb_array_p(RARRAY_PTR(ary)[i])) {</div><div class="line">      s = inspect_ary(mrb, RARRAY_PTR(ary)[i], list);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">      s = mrb_inspect(mrb, RARRAY_PTR(ary)[i]);</div><div class="line">    }</div><div class="line">    mrb_str_cat(mrb, arystr, RSTRING_PTR(s), RSTRING_LEN(s));</div><div class="line">    mrb_gc_arena_restore(mrb, ai);</div><div class="line">  }</div><div class="line"></div><div class="line">  mrb_str_cat(mrb, arystr, tail, <span class="keyword">sizeof</span>(tail));</div><div class="line">  mrb_ary_pop(mrb, list);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> arystr;</div><div class="line">}</div></div><!-- fragment --><p>This is a real example, so a little bit complicated, but bear with me. The essence of <code>Array::inspect</code> is that after stringifying each element of array using <code>inspect</code> method, we join them together so that we can get <code>inspect</code> representation of the entire array.</p>
<p>After the <code>inspect</code> representation is created, we no longer require the individual string representation. This means that we don't have to register these temporal objects into GC arena.</p>
<p>Therefore, in order to keep the arena size small; the <code>ary_inspect()</code> function will do the following:</p>
<ul>
<li>save the position of the stack top using <code>mrb_gc_arena_save()</code>.</li>
<li>get <code>inspect</code> representation of each element.</li>
<li>append it to the constructing entire <code>inspect</code> representation of array.</li>
<li>restore stack top position using <code>mrb_gc_arena_restore()</code>.</li>
</ul>
<p>Please note that the final <code>inspect</code> representation of entire array was created before the call of <code>mrb_gc_arena_restore()</code>. Otherwise, required temporal object may be deleted by GC.</p>
<p>We may have a usecase where after creating many temporal objects, we'd like to keep some of them. In this case, we cannot use the same idea in <code>ary_inspect()</code> like appending objects to existing one. Instead, after <code>mrb_gc_arena_restore()</code>, we must re-register the objects we want to keep in the arena using <code>mrb_gc_protect(mrb, obj)</code>. Use <code>mrb_gc_protect()</code> with caution because it could also lead to an "arena
overflow error".</p>
<p>We must also mention that when <code>mrb_funcall</code> is called in top level, the return value is also registered to GC arena, so repeated use of <code>mrb_funcall</code> may eventually lead to an "arena overflow error".</p>
<p>Use <code>mrb_gc_arena_save()</code> and <code>mrb_gc_arena_restore()</code> or possible use of <code>mrb_gc_protect()</code> to workaround this. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
